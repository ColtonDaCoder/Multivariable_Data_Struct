Layout {  
  UnitOfLength = 1e-09
  
  MeshOptions {
    MaximumSidelength = 50
              }


      Parallelogram  { 
        Name = "ComputationalDomain/Background" 
        DomainId = 1
        Priority = -1 
        Height =  %(pitch)e
        Width = %(pitch)e
        BoundarySegment  { 
        BoundaryClass = %(boundary)s
                         }
                 } 
  
Extrusion {
    MeshOptions {
      MaximumSidelengthZ = 50
    }    

    LayerInterface {
      BoundaryClass = Transparent
    }
    Layer {
      MeshOptions {
        ProgressionZUpper = 2
      }
      Thickness = 100 # Fused silica substrate
      DomainId = 1
    }
  }  
} 
 

<?
keys['x20'] = -1*(-(3*keys['arm_thickness']+2*keys['gap'])/2)
keys['y20'] = -(3*keys['arm_thickness']+2*keys['gap'])/2
keys['x19'] = -1*((keys['arm_thickness']/2))
keys['y19'] = -(3*keys['arm_thickness']+2*keys['gap'])/2
keys['x18'] = -1*((keys['arm_thickness']/2))
keys['y18'] = -(keys['arm_thickness']/2)
keys['x17'] = -1*((keys['arm_thickness']+2*keys['gap'])/2)
keys['y17'] = -(keys['arm_thickness']/2)
keys['x16'] = -1*((keys['arm_thickness']+2*keys['gap'])/2)
keys['y16'] = -(3*keys['arm_thickness']+2*keys['gap'])/2
keys['x15'] = -1*((3*keys['arm_thickness']+2*keys['gap'])/2)
keys['y15'] = -(3*keys['arm_thickness']+2*keys['gap'])/2
keys['x14'] = -1*((3*keys['arm_thickness']+2*keys['gap'])/2)
keys['y14'] = (keys['arm_thickness']/2)
keys['x13'] = -1*((keys['arm_thickness']/2))
keys['y13'] = (keys['arm_thickness']/2)
keys['x12'] = -1*((keys['arm_thickness']/2))
keys['y12'] = (keys['arm_thickness']+2*keys['gap'])/2
keys['x11'] = -1*((3*keys['arm_thickness']+2*keys['gap'])/2)
keys['y11'] = (keys['arm_thickness']+2*keys['gap'])/2
keys['x10'] = -1*((3*keys['arm_thickness']+2*keys['gap'])/2)
keys['y10'] = (3*keys['arm_thickness']+2*keys['gap'])/2
keys['x9'] = -1*(-(keys['arm_thickness']/2))
keys['y9'] = (3*keys['arm_thickness']+2*keys['gap'])/2
keys['x8'] = -1*(-(keys['arm_thickness']/2))
keys['y8'] = (keys['arm_thickness']/2)
keys['x7'] = -1*(-(keys['arm_thickness']+2*keys['gap'])/2)
keys['y7'] = (keys['arm_thickness']/2)
keys['x6'] = -1*(-(keys['arm_thickness']+2*keys['gap'])/2)
keys['y6'] = (3*keys['arm_thickness']+2*keys['gap'])/2
keys['x5'] = -1*(-(3*keys['arm_thickness']+2*keys['gap'])/2)
keys['y5'] = (3*keys['arm_thickness']+2*keys['gap'])/2
keys['x4'] = -1*(-(3*keys['arm_thickness']+2*keys['gap'])/2)
keys['y4'] = -(keys['arm_thickness']/2)
keys['x3'] = -1*(-(keys['arm_thickness']/2))
keys['y3'] = -(keys['arm_thickness']/2)
keys['x2'] = -1*(-(keys['arm_thickness']/2))
keys['y2'] = -(keys['arm_thickness']+2*keys['gap'])/2
keys['x1'] = -1*(-(3*keys['arm_thickness']+2*keys['gap'])/2)
keys['y1'] = -(keys['arm_thickness']+2*keys['gap'])/2
?> 

<?
keys['structure_thickness_woZrounding'] = keys['thickness'] - keys['z_radius']
?>    


Layout { 
  UnitOfLength = 1e-09

  MeshOptions {
    MaximumSidelength = 50
  }

 Parallelogram  { 
        Name = "ComputationalDomain/Background" 
        DomainId = 1
        Priority = -1 
        Height =  %(pitch)e
        Width = %(pitch)e
        BoundarySegment  { 
        BoundaryClass = %(boundary)s
                         }
                 }
      

Polygon {

        Name = "Gammadion"

        DomainId = 101

        Points = [%(x1)e %(y1)e, %(x2)e %(y2)e, %(x3)e %(y3)e, %(x4)e %(y4)e, %(x5)e %(y5)e, %(x6)e %(y6)e, %(x7)e %(y7)e, %(x8)e %(y8)e, %(x9)e %(y9)e, %(x10)e %(y10)e, %(x11)e %(y11)e, %(x12)e %(y12)e, %(x13)e %(y13)e, %(x14)e %(y14)e, %(x15)e %(y15)e, %(x16)e %(y16)e, %(x17)e %(y17)e, %(x18)e %(y18)e, %(x19)e %(y19)e, %(x20)e %(y20)e]

        
        RotationAngle = %(angle)e
        MeshOptions {
         MaximumSidelength = 50
        }
		
        CornerRounding {
          Point = [1,4,5,6,9,10,11,14,15,16,19,20]
          Radius = 40
          NPoints = 8
        }
        


          CornerRounding {
          Point = [2,3,7,8,12,13,17,18]
          Radius = 4
          #NPoints = 8
        }

                       }

           
 Extrusion {
 
      LayerInterface {
      GlobalZ = 0.0
    }
    
    MeshOptions {
      MaximumSidelengthZ = 50
      
        
    }    

    Layer {
      MeshOptions {
        MaximumSidelengthZLower = 5
        MaximumSidelengthZUpper = 5
      }
      
      Thickness = %(adhesion_thickness)e #Titanium Adhesion Layer
      DomainIdMapping = [1 3 
      101 2]

    }


    Layer {
      MeshOptions {
        MaximumSidelengthZLower = 5
        MaximumSidelengthZUpper = 5
      }
      
      Thickness = %(structure_thickness_woZrounding)e #Aluminum Gammadion
      DomainIdMapping = [1 3 
      101 4]

    }




    
 

 #Z-Rounding Process
<?
import numpy as np
keys['num_Zradius_dimers'] = keys['z_radius']/keys['z_radius_MSL'] # The number of dimer slices in the Z-radius rounding
z_step = keys['z_radius']/keys['z_radius_MSL']
i=1
while i <= keys['num_Zradius_dimers']:
  keys['step'] = keys['z_radius'] - ((keys['z_radius']**2 - (keys['z_radius_MSL']*i)**2)**(1/2))
  
  keys['x20'] = -1*(-(3*keys['arm_thickness']+2*keys['gap'])/2 + keys['step'])
  keys['y20'] = -(3*keys['arm_thickness']+2*keys['gap'])/2 + keys['step']
  keys['x19'] = -1*((keys['arm_thickness']/2) - keys['step'])
  keys['y19'] = -(3*keys['arm_thickness']+2*keys['gap'])/2 + keys['step']
  keys['x18'] = -1*((keys['arm_thickness']/2) - keys['step'])
  keys['y18'] = -(keys['arm_thickness']/2) + keys['step']
  keys['x17'] = -1*((keys['arm_thickness']+2*keys['gap'])/2 + keys['step'])
  keys['y17'] = -(keys['arm_thickness']/2) + keys['step'] +  keys['step']
  keys['x16'] = -1*((keys['arm_thickness']+2*keys['gap'])/2 +  keys['step'])
  keys['y16'] = -(3*keys['arm_thickness']+2*keys['gap'])/2 +  keys['step']
  keys['x15'] = -1*((3*keys['arm_thickness']+2*keys['gap'])/2 - keys['step'])
  keys['y15'] = -(3*keys['arm_thickness']+2*keys['gap'])/2 +  keys['step']
  keys['x14'] = -1*((3*keys['arm_thickness']+2*keys['gap'])/2 - keys['step'])
  keys['y14'] = (keys['arm_thickness']/2) - keys['step']
  keys['x13'] = -1*((keys['arm_thickness']/2) - keys['step'])
  keys['y13'] = (keys['arm_thickness']/2) - keys['step']
  keys['x12'] = -1*((keys['arm_thickness']/2) - keys['step'])
  keys['y12'] = (keys['arm_thickness']+2*keys['gap'])/2 + keys['step']
  keys['x11'] = -1*((3*keys['arm_thickness']+2*keys['gap'])/2 - keys['step'])
  keys['y11'] = (keys['arm_thickness']+2*keys['gap'])/2 + keys['step']
  keys['x10'] = -1*((3*keys['arm_thickness']+2*keys['gap'])/2 - keys['step'])
  keys['y10'] = (3*keys['arm_thickness']+2*keys['gap'])/2 - keys['step']
  keys['x9'] = -1*(-(keys['arm_thickness']/2) +  keys['step'])
  keys['y9'] = (3*keys['arm_thickness']+2*keys['gap'])/2 -  keys['step']
  keys['x8'] = -1*(-(keys['arm_thickness']/2) + keys['step'])
  keys['y8'] = (keys['arm_thickness']/2) - keys['step']
  keys['x7'] = -1*(-(keys['arm_thickness']+2*keys['gap'])/2 - keys['step'])
  keys['y7'] = (keys['arm_thickness']/2) - keys['step']
  keys['x6'] = -1*(-(keys['arm_thickness']+2*keys['gap'])/2 - keys['step'])
  keys['y6'] = (3*keys['arm_thickness']+2*keys['gap'])/2 - keys['step']
  keys['x5'] = -1*(-(3*keys['arm_thickness']+2*keys['gap'])/2 + keys['step'])
  keys['y5'] = (3*keys['arm_thickness']+2*keys['gap'])/2 - keys['step']
  keys['x4'] = -1*(-(3*keys['arm_thickness']+2*keys['gap'])/2 + keys['step'])
  keys['y4'] = -(keys['arm_thickness']/2) + keys['step']
  keys['x3'] = -1*(-(keys['arm_thickness']/2) + keys['step'])
  keys['y3'] = -(keys['arm_thickness']/2) + keys['step']
  keys['x2'] = -1*(-(keys['arm_thickness']/2) + keys['step'])
  keys['y2'] = -(keys['arm_thickness']+2*keys['gap'])/2 - keys['step']
  keys['x1'] = -1*(-(3*keys['arm_thickness']+2*keys['gap'])/2 + keys['step'])
  keys['y1'] = -(keys['arm_thickness']+2*keys['gap'])/2 -  keys['step']
  
  
  i=i+1
  ?>
Layer {
  Thickness = %(z_radius_MSL)e
  DomainIdMapping = [1 3 ##Air
                    101 4
					] ##Aluminum
}

LayerInterface {
  GeometryValues = [
    Gammadion/Points = [%(x1)e %(y1)e, %(x2)e %(y2)e, %(x3)e %(y3)e, %(x4)e %(y4)e, %(x5)e %(y5)e, %(x6)e %(y6)e, %(x7)e %(y7)e, %(x8)e %(y8)e, %(x9)e %(y9)e, %(x10)e %(y10)e, %(x11)e %(y11)e, %(x12)e %(y12)e, %(x13)e %(y13)e, %(x14)e %(y14)e, %(x15)e %(y15)e, %(x16)e %(y16)e, %(x17)e %(y17)e, %(x18)e %(y18)e, %(x19)e %(y19)e, %(x20)e %(y20)e]
	]
}

<?
?>
}
}

Layout {
  UnitOfLength = 1e-09

  MeshOptions {
    MaximumSidelength = 50
  }

      Parallelogram  { 
        Name = "ComputationalDomain/Background" 
        DomainId = 1
        Priority = -1 
        Height =  %(pitch)e
        Width = %(pitch)e
        BoundarySegment  { 
        BoundaryClass = %(boundary)s
                         }
                 } 

  Extrusion {
    MeshOptions {
      MaximumSidelengthZ = 50
    }    

    Layer {
      Thickness = 150
      DomainId = 3 #Air
    }
    LayerInterface {
      BoundaryClass = Transparent
    }
  }  

}
